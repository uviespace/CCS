#!/usr/bin/env python3
"""
Generates a small Test Script from an existing json Test Specification, mostly used during internal testing and
debugging Process, For the real tests the more extensive Test Scripts are generated by the TST (included logging,
step id, run id,...)
author: Marko Mecina
date: 01.08.2021
edited: Dominik MÃ¶slinger
"""

import datetime
import os
import json
import sys

MIB_VERSION = '1.8.1'


def run(jfile, outfile, reportfunc=False, specfile=None):

    if os.path.isfile(jfile):
        data = json.load(open(jfile, 'r'))
    else:
        data = json.loads(jfile)

    date = datetime.datetime.now().strftime('%Y-%m-%d')

    script = ''

    script += '#--------------------------------------------\n'
    script += '# ' + data['_name'] + '\n'
    script += '# ' + data['_description'] + '\n'
    script += '# Specification Version: ' + data['_spec_version'] + '\n'
    script += '# Software Version: ' + data['_iasw_version'] + '\n'
    script += '# Author: UVIE\n# Date: {}\n'.format(date)
    script += '#--------------------------------------------\n\n'
    script += '# COMMENT: {}\n\n\n'.format(data['_comment'].replace('\n', '\n# '))

    if reportfunc:
        if specfile is None:
            specfile = '{}-TS-{}.csv_PIPE'.format(data['_name'], data['_spec_version'])
        script += 'specfile = "{}"\n'.format(specfile)
        script += 'rep_version = 1\n'
        script += 'mib_version = "{}"\n'.format(MIB_VERSION)
        script += 'ask_tc_exec = True\n'
        script += 'report = cfl.TestReport(specfile, rep_version, mib_version, gui=True)\n\n'

    # init code
    script += '# INIT CODE\n{}\n#! CCS.BREAKPOINT\n\n'.format(data['_custom_imports'])

    script += '# PRECONDITIONS\n# {}\n#! CCS.BREAKPOINT\n\n'.format(replace_newline(data['_precon_descr']))
    # script += '{}\n\n\n'.format(data['_precon_code'].strip())  # Add the precondition code

    for step in data['sequences'][0]['steps']:
        comment = '# COMMENT: {}\n'.format(step['_step_comment'].strip()) if step['_step_comment'] != '' else ''
        cmd_code = step['_command_code'].strip()
        cmd_code += '\n' if cmd_code else ''

        if reportfunc:
            step_tag = 'Step {}'.format(step['_step_number'])
            exec_step = 'report.execute_step("{}", ask=ask_tc_exec)\n'.format(step_tag)
            verif_step = 'report.verify_step("{}")\n'.format(step_tag)
        else:
            exec_step = ''
            verif_step = ''

        txt = '# STEP {}\n' \
              '# {}\n' \
              '{}' \
              '{}' \
              '# VERIFICATION: {}\n{}{}\n#! CCS.BREAKPOINT\n\n'.format(step['_step_number'], step['_description'].strip(), exec_step,
                                                                      cmd_code,
                                                                      step['_verification_description'].strip(),
                                                                      verif_step,
                                                                      # step['_verification_code'].strip(), # Add verification code
                                                                      comment)

        script += txt

    script += '# POSTCONDITIONS\n# {}\n'.format(replace_newline(data['_postcon_descr']))
    # script += data['_postcon_code'].strip()  # Add the postcondition code

    if reportfunc:
        script += '\nreport.export()\n\n'

    if outfile[-1] == '/':  # If path is given not the actual filename
        outfile = outfile + data['_name'] + '-TS-' + '-'.join(data['_spec_version']) + '.py'

    with open(outfile, 'w') as fd:
        fd.write(script)


def replace_newline(txt):
    return txt.strip().replace('\n', '\n# ')


if __name__ == '__main__':
    json_file_path = sys.argv[1]

    if len(sys.argv) > 2:  # If filename is given
        outputfile = sys.argv[2]
    else:  # If no filename is given take the working directory path, filename is used from the json file
        outputfile = os.getcwd() + '/'
        #outputfile = '/'.join(json_file_path[:-len(json_file_path.split('/')[-1])-1]) + '/'  # This would take the json File path

    run(json_file_path, outputfile, reportfunc=False)
